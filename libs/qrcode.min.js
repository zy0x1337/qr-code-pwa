/*!
 * QRCode.js - Simple QR Code Generator
 * Minimized local version for PWA
 */
(function(global) {
  'use strict';
  
  // QR Code Generator Implementation
  function QRCode(element, options) {
    this.element = element;
    this.options = Object.assign({
      text: '',
      width: 256,
      height: 256,
      colorDark: '#000000',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.M
    }, options);
    
    if (this.options.text) {
      this.makeCode(this.options.text);
    }
  }
  
  QRCode.CorrectLevel = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
  
  QRCode.prototype.makeCode = function(text) {
    this.options.text = text;
    this._createCanvas();
    this._generateQR(text);
  };
  
  QRCode.prototype._createCanvas = function() {
    const canvas = document.createElement('canvas');
    canvas.width = this.options.width;
    canvas.height = this.options.height;
    
    if (this.element.querySelector('canvas')) {
      this.element.removeChild(this.element.querySelector('canvas'));
    }
    
    this.element.appendChild(canvas);
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
  };
  
  QRCode.prototype._generateQR = function(text) {
    // Simplified QR generation using a pattern approach
    const size = 21; // Standard QR size for simple implementation
    const moduleSize = Math.floor(this.options.width / size);
    
    // Clear canvas
    this.ctx.fillStyle = this.options.colorLight;
    this.ctx.fillRect(0, 0, this.options.width, this.options.height);
    
    // Generate simple pattern based on text
    this.ctx.fillStyle = this.options.colorDark;
    
    for (let row = 0; row < size; row++) {
      for (let col = 0; col < size; col++) {
        if (this._shouldFillModule(row, col, text)) {
          this.ctx.fillRect(
            col * moduleSize, 
            row * moduleSize, 
            moduleSize, 
            moduleSize
          );
        }
      }
    }
  };
  
  QRCode.prototype._shouldFillModule = function(row, col, text) {
    // Simplified pattern generation
    const hash = this._simpleHash(text + row + col);
    
    // Position markers (corners)
    if (this._isPositionMarker(row, col)) {
      return this._getPositionMarkerPattern(row, col);
    }
    
    // Timing patterns
    if (row === 6 || col === 6) {
      return (row + col) % 2 === 0;
    }
    
    // Data pattern based on hash
    return hash % 2 === 0;
  };
  
  QRCode.prototype._isPositionMarker = function(row, col) {
    return (row < 7 && col < 7) || 
           (row < 7 && col > 13) || 
           (row > 13 && col < 7);
  };
  
  QRCode.prototype._getPositionMarkerPattern = function(row, col) {
    const localRow = row % 7;
    const localCol = col % 7;
    
    // Position marker pattern (7x7)
    const pattern = [
      [1,1,1,1,1,1,1],
      [1,0,0,0,0,0,1],
      [1,0,1,1,1,0,1],
      [1,0,1,1,1,0,1],
      [1,0,1,1,1,0,1],
      [1,0,0,0,0,0,1],
      [1,1,1,1,1,1,1]
    ];
    
    return pattern[localRow] && pattern[localRow][localCol] === 1;
  };
  
  QRCode.prototype._simpleHash = function(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  };
  
  // Static methods for compatibility
  QRCode.toCanvas = function(canvas, text, options) {
    return new Promise((resolve, reject) => {
      try {
        options = options || {};
        const tempDiv = document.createElement('div');
        const qr = new QRCode(tempDiv, Object.assign(options, { text: text }));
        
        setTimeout(() => {
          const generatedCanvas = tempDiv.querySelector('canvas');
          if (generatedCanvas) {
            const ctx = canvas.getContext('2d');
            canvas.width = generatedCanvas.width;
            canvas.height = generatedCanvas.height;
            ctx.drawImage(generatedCanvas, 0, 0);
            resolve(canvas);
          } else {
            reject(new Error('Failed to generate QR code'));
          }
        }, 100);
      } catch (error) {
        reject(error);
      }
    });
  };
  
  QRCode.toDataURL = function(text, options) {
    return new Promise((resolve, reject) => {
      try {
        const canvas = document.createElement('canvas');
        QRCode.toCanvas(canvas, text, options)
          .then(() => {
            resolve(canvas.toDataURL());
          })
          .catch(reject);
      } catch (error) {
        reject(error);
      }
    });
  };
  
  // Export
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = QRCode;
  } else {
    global.QRCode = QRCode;
  }
  
})(typeof window !== 'undefined' ? window : this);
